---
title: "analysis"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
libarary(boot)
library(brms)
library(here)
library(latex2exp)
library(scales)
library(tidybayes)
library(tidyverse)
source(here("R", "utils.R"))

theme_set(theme_minimal(base_size=12) + theme(legend.position = "top"))
target_dir = here("results", "experiment2", "pretests")
plot_dir = file.path(target_dir, "figs")
if(!file.exists(plot_dir)) dir.create(plot_dir, recursive = TRUE)
```

Load experimental data

```{r}
fn <- file.path(target_dir, "results_82_CommunicationBlocks2_BG_last_test.csv")
data <- read.csv(fn, sep=",") %>% as_tibble() %>% group_by(submission_id)
```

Sanity checks
pic1, pic2, pic3 is the same for all participants (but occur in random order)

```{r}
N = data$submission_id %>% unique() %>% length()
data %>% ungroup %>% select(id, type, pic1, pic2, pic3) %>% 
  group_by_all() %>% 
  dplyr::count() %>% filter(n != N)
```

## Attention-check for Prolific

1. Filter out participants who did not get attention checks right

```{r}
attention_checks = data %>% filter(type=="attention-check") %>% 
  dplyr::select(submission_id, id, selected_pic, expected, comments) %>% 
  mutate(correct = case_when(expected == selected_pic ~ TRUE, T ~ FALSE)) 

ids.attention_out = attention_checks %>% filter(expected != selected_pic) %>% 
  dplyr::select(submission_id, comments) %>% distinct()

attention_checks %>% group_by(correct) %>% dplyr::count()
ids.attention_out
```

2. How often did each participant select a contrast picture? Or all three pics?

```{r}
data.test = data %>% filter(str_detect(trial_name, "image_selection"))
df.selected_pics = data.test %>% select(submission_id, response, id, type) %>% 
  mutate(response = case_when(length(str_split(response, "_")[[1]]) == 3 ~ "all", 
                              T ~ response))

ids.select3 = df.selected_pics %>% filter(response == "all")
ids.select3

df.ids.contrast = df.selected_pics %>% filter(str_detect(response, "contrast"))
df.ids.contrast
```

3. Look at participants' responses to questions shown in the end

```{r}
data %>% dplyr::select(submission_id, check_ann) %>% 
  distinct() %>% group_by(check_ann) %>% dplyr::count()
data %>% dplyr::select(submission_id, check_behavior) %>% 
  distinct() %>% group_by(check_behavior) %>% dplyr::count()
```

4. Participants' comments

```{r}
data %>% select(comments, submission_id, prolific_id) %>% distinct()
```


## Load cleaned data 

Data was cleaned (see script clean_data.R) according to predefined exclusion criteria

```{r, message=FALSE}
# TODO: write clean_data_exp2()
# data = read_csv(here("results", "data_cleaned.csv"))
```

Trials where a pragmatic and a literal selection is possible

```{r}
trials_lit_prag = c("trial7", "trial8", "trial19", "trial20", "trial21", "trial24")
data.lit_prag <- data %>% filter(id %in% trials_lit_prag) %>% 
  dplyr::select(submission_id, response, type, id, response) %>% group_by(id)

# by trials
data.lit_prag %>% 
  ggplot(aes(x=id, fill=response)) + 
  geom_bar(stat="count", position=position_dodge()) +
  scale_y_continuous(breaks = pretty_breaks())

pic_props = data.test %>% ungroup() %>% 
  select(starts_with("property_"), type, id) %>% 
  unite(col="props", "property_pic1", "property_pic2", "property_pic3", sep="_") %>% 
  distinct() %>% arrange(type)

pic_props %>% filter(id %in% trials_lit_prag)
```

Scores for participants how pragmatic their responses were. 
1: pragmatic picture selected (pragmatic)
0.5: pragmatic + literal picture selected (literal2)
0: literal picture selected (literal1)

Max score:6
Min score:0

```{r}
data.pragmatic_score = data.lit_prag %>% 
  mutate(score = case_when(response == "pragmatic" ~ 1,
                           response == "literal" ~ 0, 
                           T ~ 0.5)) %>% 
  group_by(submission_id) %>% summarize(score = sum(score), .groups = "drop") %>% 
  mutate(relative_score = round(score / 6, 2))

data.pragmatic_score %>% 
  ggplot(aes(x=score)) + geom_bar() + 
  labs(x = "pragmatic score", y = "nb participants") +
  scale_x_continuous(breaks = pretty_breaks())
```

Practice trials

```{r}
data.practice = data.test %>% filter(type == "practice") %>% 
   dplyr::select(submission_id, response, id)

data.practice %>% ggplot(aes(x=id, fill=response)) + 
  geom_bar(stat="count", position=position_dodge()) +
  scale_y_continuous(breaks = pretty_breaks())

pic_props %>% filter(type == "practice")
```

Trials, where a selection of one is risky since no clue for neither of both
Trial11 is a practice trial, trial13 a filler trial.

```{r}
risk_trials = c("trial11", "trial13")
data.risk <- data %>% filter(id %in% risk_trials) %>% 
  dplyr::select(submission_id, response, id, type)

data.risk %>% ggplot(aes(x=id, fill=response)) + 
  geom_bar(stat="count", position=position_dodge()) +
  scale_y_continuous(breaks= pretty_breaks())

pic_props %>% filter(id %in% risk_trials)
```

## Meta information about participants

```{r, meta, echo=FALSE}
data.meta <- data %>% 
  distinct_at(vars(c(submission_id)), .keep_all = T) %>%
  mutate(education=as_factor(education), gender=as_factor(gender))

data.meta$gender %>% summary()
data.meta$education %>% summary()
print("age:")
data.meta$age %>% summary()
print("timeSpent:")
data.meta$timeSpent %>% summary()

data.meta %>% ggplot(aes(x="time", y=timeSpent)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter() +
  labs(x="")
```

## Participants' scores

```{r}
data.test_scores = data %>% filter(type != "training") %>% 
  dplyr::select(prolific_id, submission_id, score, type, id) %>%
  group_by(type, prolific_id) %>%
  mutate(prolific_id = as.factor(prolific_id))

df.max = data.test_scores %>% group_by(type) %>% dplyr::select(type, id) %>% 
  distinct() %>% summarize(n=n()) %>% 
  mutate(max = case_when(type == "practice" ~ n*100-50, 
                         T ~ n * 100))
data.test_scores %>% 
  summarize(score = sum(score), .groups = "drop_last") %>% 
  ggplot(aes(x=prolific_id, y=score, fill=type)) + 
  geom_hline(data = df.max, aes(yintercept = max, color = type)) +
  geom_bar(stat="identity", position = position_dodge())
```

## Training data

Sanity check: does ratio of correct answers increase with increasing trial numbers?

```{r}
data.train = data %>% filter(type=="training") %>%
  mutate(correct=case_when(expected == response ~ T, T ~ F))

# ratio correct by participants
data.train %>% dplyr::select(submission_id, id, correct) %>% 
  summarize(nb_trials = n(), nb_correct = sum(correct)) %>% 
  mutate(ratio_correct = nb_correct / nb_trials, 
         submission_id = as.character(submission_id)) %>% 
  ggplot(aes(x=submission_id, y=ratio_correct)) + geom_bar(stat="identity") +
  geom_hline(aes(yintercept = 0.5))


# ratio correct per trial number (different order per participant)
train.correct.nb = data.train %>% group_by(trial_number) %>% 
  summarize(mean_correct = mean(correct))
train.correct.nb %>% 
  ggplot(aes(x=trial_number, y=mean_correct)) + 
  geom_bar(stat="identity") + 
  scale_x_continuous(breaks = scales::pretty_breaks(8)) +
  geom_hline(aes(yintercept = 0.5))


# ratio correct per trial id
train.correct.id = data.train %>% group_by(id) %>% 
  summarize(mean_correct = mean(correct))
train.correct.id %>% 
  ggplot(aes(x=id, y=mean_correct)) + 
  geom_bar(stat="identity") +
  theme(axis.text.x=element_text(angle=90)) + 
  geom_hline(aes(yintercept = 0.5))
```


## Plot critical trials

```{r}
QUDs = c(netural = "Which blocks do you think will fall?",
         ifp = "What happens if the 'antecedent-block' falls?",
         willq = "Will the 'consequent-block' fall?")
```

```{r, data-critical, echo=FALSE}
data.critical = data %>% 
  filter(type=="critical") %>% 
  select(submission_id, id, type, QUD, response, selected_pic, pic2, pic3, RT) %>% 
  mutate(pic2=str_replace(pic2, ".png", ""), pic2=str_replace(pic2, "_horiz", ""),
         pic3 = str_replace(pic3, ".png", ""), pic3=str_replace(pic3, "_horiz", "")) %>% 
  mutate(picPair=paste(pic2, pic3, sep=" & "),
         picPair.long = 
           case_when(picPair == "if2_unn & if2_unu" ~ "D. withDistractor-external", 
                     picPair == "if1_un & if2_unu" ~ "B. w/oDistractor-external",
                     picPair == "if1_un & if1_uu" ~ "A. w/oDistractor-internal",
                     picPair == "if2_unn & if1_uu" ~ "C. withDistractor-internal")) %>% 
  dplyr::select(-pic2, -pic3) %>%
  mutate(picPair.short = substr(picPair.long, 1, 1))

# by QUD
data.critical %>% group_by(QUD, response) %>% 
  summarize(n=n(), .groups = "drop_last") %>% 
  mutate(ratio = n / sum(n)) %>% 
  ggplot(aes(fill=response, y=QUD, x=ratio)) + 
  geom_bar(stat="identity", position=position_dodge(preserve = 'single'))

# by trial
data.critical %>% group_by(picPair.long, QUD, response) %>% 
  summarize(n=n(), .groups = "drop_last") %>% 
  mutate(ratio = n / sum(n)) %>% 
  ggplot(aes(fill=response, y=QUD, x=ratio)) + 
  geom_bar(stat="identity", position=position_dodge(preserve = 'single')) +
  facet_wrap(~picPair.long, scales = "free")
```

Results with 95%-bootstrap confidence intervals

```{r}
N = 1000
n_participants = data.critical$submission_id %>% unique() %>% length()
CI_bounds = c(low = ceiling(0.025 * N), up = ceiling(0.975 * N))

df.critical <- data.critical %>% 
  group_by(picPair.long, picPair.short, QUD) %>% 
  dplyr::select(submission_id, picPair.long, picPair.short, QUD, response) %>% 
  mutate(response = case_when(response == "exhaustive_non-exhaustive" ~ "both",
                              T ~ response))
df.crit.exh = df.critical %>% 
  mutate(response = case_when(response == "exhaustive" ~ 1, T ~ 0))
df.crit.nonExh = df.critical %>% 
  mutate(response = case_when(response == "non-exhaustive" ~ 1, T ~ 0))
df.crit.both = df.critical %>% 
  mutate(response = case_when(response == "both" ~ 1, T ~ 0))

get_mean_selection_rate <- function(dat, indices) {
  return(dat[indices, ] %>% pull(response) %>% mean())
}
get_bootstrap_samples = function(dat, response) {
  bootstrap_samples <- group_map(dat, function(df, df.group) {
    samples = boot(df, statistic = get_mean_selection_rate, R=N)$t
    return(tibble(rate = samples[,1]) %>% 
      add_column(picPair.long = df.group$picPair.long, 
                 picPair.short = df.group$picPair.short,
                 QUD = df.group$QUD) %>% arrange(rate) %>% rowid_to_column("idx"))
  }) %>% bind_rows() %>% add_column(response = response)
  return(bootstrap_samples)
}

bootstrap_samples = bind_rows(
  get_bootstrap_samples(df.crit.both, "both"),
  get_bootstrap_samples(df.crit.exh, "exhaustive"),
  get_bootstrap_samples(df.crit.nonExh, "non-exhaustive")
) %>% group_by(picPair.long, picPair.short, QUD, response)

CIs <- bootstrap_samples %>% 
  mutate(CI = case_when(idx == CI_bounds[["low"]] ~ "ci.low",
                        idx == CI_bounds[["up"]] ~ "ci.up")) %>% 
  filter(!is.na(CI)) %>% dplyr::select(-idx) %>% 
  pivot_wider(names_from = "CI", values_from = "rate") %>% 
  arrange(picPair.short)
```

```{r, critical-data-rates, echo = FALSE}
data.critical.rate = df.critical %>% 
  group_by(picPair.long, picPair.short, QUD, response) %>% 
  summarize(n=n(), .groups = "drop_last") %>% 
  mutate(ratio = n/sum(n))

data.critical.rate = left_join(
  data.critical.rate,
  CIs, 
  by=c("QUD", "picPair.long", "picPair.short", "response")
)
```

1. across all different instantiations, i.e. exhaustive/non-exhaustive 
picture combinations

```{r}
conditions = configure(c("QUDs"))
data.critical %>%
  ggplot(aes(fill=response, y=QUD)) + 
  geom_bar(position=position_dodge(preserve = 'single')) +
  scale_y_discrete(breaks=names(conditions), labels = conditions) + 
  labs(y="Ann's question") +
  guides(fill = guide_legend(ncol = 2))

# same plot with exhaustive-picture selection ratios instead of absolute numbers
data.critical.rate %>% group_by(QUD, response) %>% 
  mutate(ratio = mean(ratio)) %>% distinct_at(vars(c(QUD, response)), .keep_all = T) %>% 
  ggplot(aes(x=ratio, y=QUD, fill=response, group = response)) + 
  geom_bar(stat="identity", position = position_dodge()) + 
  geom_errorbar(aes(xmin=ci.low, xmax=ci.up), 
                position = position_dodge()) +
  geom_text(aes(label=round(ratio, 2)), hjust=-0.25, vjust=-0.45, color = 'blue',
            position = position_dodge(width = .9)) +
  scale_y_discrete(breaks=names(conditions), labels = conditions) + 
  labs(y="Ann's question", x="selection rate") +
  guides(fill = guide_legend(ncol = 2))
```

2. split among different instantiations of critical trials 
(i.e., across different picture combinations)

```{r}
p = data.critical.rate %>% 
  mutate(condition = factor(picPair.long), 
         QUD = case_when(QUD == "willq" ~ "will-q",
                         QUD == "ifp" ~ "if-p", 
                         T ~ QUD),
         QUD = as.factor(QUD)) %>% 
  ggplot(aes(x=ratio, y=QUD, fill=response, group=response)) + 
  geom_bar(stat="identity", position = position_dodge()) + 
  geom_errorbar(aes(xmin=ci.low, xmax=ci.up), position = position_dodge()) +
  geom_text(aes(label=round(ratio, 2)), hjust=-0.25, vjust=-0.3,
            position = position_dodge(width = .9), color='blue') +
  facet_wrap(~condition) + 
  labs(x="selection rate", y = "QUD")
p
ggsave(here(plot_dir, "selection-rates.pdf"), p, width=7, height=4)
```

Analysis with 3x2x2 design

```{r}
get_responses_all_QUDs = function(dat){
  df = dat %>% group_by(submission_id, picPair.long, picPair.short) %>% 
    dplyr::select(submission_id, picPair.long, picPair.short, QUD, response)

  df.wide = df %>% group_by(picPair.long, picPair.short, submission_id) %>% 
    mutate(response = str_replace(response, "non-exhaustive", "nonExh"), 
           response = str_replace(response, "exhaustive", "exh")) %>% 
    pivot_wider(names_from = QUD, values_from = response, values_fill = "-") %>% 
    unite("ifp.willq", ifp, willq, sep="/") %>% 
    mutate(ifp.willq = factor(ifp.willq, 
                              levels = c("exh/-", # if-p: exh
                                         "nonExh/-", # if-p: nonExh
                                         "exh_nonExh/-", #if-p: exh and nonExh
                                         "exh/exh", # if-p and will-q: exh
                                         "exh_nonExh/exh_nonExh", # ...
                                         "exh_nonExh/exh", 
                                         "exh/exh_nonExh"),
                              labels = c("e/-", "n/-", "e_n/-", "e/e", 
                                         "e_n/e_n", "e_n/e", "e/e_n")),
           stimulus = picPair.long) %>% 
    separate(picPair.long, into = c("exh", "nonExh"), sep = "-") %>%
    separate(exh, into = c("tmp", "exh"), sep=". ") %>% select(-tmp) %>% 
    rename(response = ifp.willq)
  return(df.wide)
}

plot_responses_all_QUDs = function(dat) {
  df.wide <- get_responses_all_QUDs(dat)
  df.wide.count = df.wide %>% group_by(stimulus, picPair.short, response) %>% 
    dplyr::count() %>% group_by(stimulus) %>% mutate(N=sum(n), ratio=n/N)
  
  xlab = "selected situation for both QUDs: if-p/will-q"
  p <- df.wide.count %>% ggplot(aes(x=response, y=ratio , fill=response)) + 
    geom_bar(stat="identity", position=position_dodge()) +
    geom_label(aes(label=n)) +
    scale_fill_brewer(palette='Set2', name="response ifp_willq") +
    facet_wrap(~stimulus, nrow = 2, scales = "free") +
    theme(legend.position = "none") +
    labs(y = "ratio participants", x=xlab)
  return(p)
}
p <- plot_responses_all_QUDs(data.critical)
p
ggsave(file.path(plot_dir, "empirical-responses.pdf"), p, width=7, height=4)
```

Score participants: for the two critical stimuli that occur with both QUDs 
(B + D), participants receive 1 point if they differentiate the QUDs ifp_willq, 
i.e. when they choose the exhaustive picture for one QUD and the non-exhaustive
for the other (independent of direction).
A score of 0 then means that the respective participant never made a difference 
between the two quds and a score of two that participant always made a difference
between them.

```{r}
responses.all_quds = get_responses_all_QUDs(data.critical) %>% 
  separate("response", into = c("ifp", "willq"), sep="/") %>% 
  mutate(score = case_when(ifp == willq ~ 0, T ~ 1)) %>% filter(willq != "-") 

df.scores = responses.all_quds %>% group_by(submission_id) %>%
  summarize(score.total=sum(score))
df.scores %>% ggplot(aes(x=score.total)) + geom_bar() +
  labs(x="nb times participants gave different answers for different QUDs", 
       y = "nb participants")

ids.scores12 <- df.scores %>% filter(score.total <= 2 & score.total >= 1) %>% 
  pull(submission_id)
plot_responses_all_QUDs(data.critical %>% filter(submission_id %in% ids.scores12)) +
  ggtitle("Participants with 0 or 1 ignorance of QUD")
```

Those who never take QUD into account, do they switch between exh-exh and 
nonExh-nonExh or always give the same (identical) answer?

```{r}
ids.score0 = df.scores %>% filter(score.total == 0) %>% pull(submission_id)
df.ignored_qud = responses.all_quds %>% filter(submission_id %in% ids.score0) %>% 
  group_by(submission_id, ifp, willq) %>% 
  dplyr::count(name="nb_stimuli") %>%
  arrange(submission_id) %>% 
  rename(selection = ifp) %>% ungroup() %>% dplyr::select(-willq)

# pair with participants pragmatic scores
left_join(df.ignored_qud, 
          data.pragmatic_score %>% 
            dplyr::select(submission_id, relative_score) %>% 
            rename(score_pragmatic = relative_score), 
          by="submission_id")
```

Plot empirical selection rates

```{r}
df <- data.critical.rate %>% 
  mutate(condition = factor(picPair.long), 
         QUD = case_when(QUD == "willq" ~ "will-q",
                         QUD == "ifp" ~ "if-p", 
                         T ~ QUD),
         QUD = as.factor(QUD)) %>% 
  separate(col = picPair.long, into = c("exh_situation", "nonExh_situation"), sep="-") %>%
  mutate(exh_situation = str_sub(exh_situation, start=4),
         exh_situation = factor(exh_situation, levels = c("withDistractor", "w/oDistractor")))

w_dodge = 0.25
p <- df %>% mutate(response = str_replace(response, "non-exhaustive", "nonExh"),
                   response = str_replace(response, "exhaustive", "exh")) %>% 
  ggplot(aes(x=QUD, y=ratio, shape = picPair.short, color = response)) +
             #group=interaction(QUD, nonExh_situation))) +
  geom_point(position = position_dodge(width=w_dodge)) +
  geom_errorbar(aes(ymin=ci.low, ymax=ci.up), width=0.1, 
                position = position_dodge(width=w_dodge)) +
  #geom_line(position = position_dodge(width=w_dodge)) +
  #labs(y = "selection rates", x = "exhaustive situation") +
  labs(x="stimulus", y="selection rate") +
  scale_color_brewer(name = "selection", palette = "Set2") +
  guides(color = guide_legend(title.position="top"),
         shape = guide_legend(title = "stimulus", title.position="top"))

p
 ggsave(file.path(plot_dir, "empirical-responses-rates-bypic.pdf"), p, 
       width=7, height=4)

p <- df %>% mutate(response = str_replace(response, "non-exhaustive", "nonExh"),
                   response = str_replace(response, "exhaustive", "exh")) %>% 
  ggplot(aes(x=QUD, y=ratio, color = response, shape = picPair.short)) +  
             # group=interaction(QUD, nonExh_situation))) +
  geom_point(position = position_dodge(width=w_dodge)) +
  geom_errorbar(aes(ymin=ci.low, ymax=ci.up), width=0.1, 
                position = position_dodge(width=w_dodge)) +
  # geom_line(position = position_dodge(width=w_dodge)) +
  # labs(y = "selection rates", x = "exhaustive situation") +
  scale_color_brewer(name = "selection", palette = "Set2") +
  guides(color = guide_legend(title.position="top"), 
         shape = guide_legend(title = "stimulus", title.position="top")) +
  facet_grid(exh_situation ~ nonExh_situation, scales = "free_x")
p
ggsave(file.path(plot_dir, "empirical-responses-rates-233.pdf"), p, width=7, height=4)

```


## Bayesian regression model

1. Predict selection only based on QUD 

```{r, results='hide'}
model_path = here(target_dir, "brms-model1.rds")
data.critical.model = data.critical %>% 
  rename(picPair.full = picPair, picPair = picPair.short) %>% 
  mutate(selected_pic = str_replace_all(selected_pic, "_", ""),
         response = str_replace(response, "non-exhaustive", "nonExh"),
         response = str_replace(response, "exhaustive", "exh"), 
         response = str_replace(response, "exh_nonExh", "both"), 
         QUD = as.factor(QUD))
         
if(file.exists(model_path)) {
  fit1 <- readRDS(model_path)
} else {
  fit1 <- brm(data=data.critical.model, 
              family = categorical(link = "logit"), 
              response ~ 1 + QUD + (0 + QUD | submission_id), 
              iter = 4000)
  saveRDS(fit1, file=model_path)
}
betas1 <- fixef(fit1)[, 'Estimate']
pp_check(fit1)
mcmc_plot(fit1)
pp_check(fit, type = "stat", stat = 'mean', nsamples = 100)
```

Testing our hypotheses for model with predictor only QUD

```{r, regression-hypotheses}
# predicted probabilities
exh_willq = inv_logit_scaled(betas1['muexh_Intercept'] + betas1['muexh_QUDwillq'])
exh_ifp = inv_logit_scaled(betas1['muexh_Intercept'])
nonExh_willq = inv_logit_scaled(betas1['munonExh_Intercept'] + 
                                  betas1['munonExh_QUDwillq'])
nonExh_ifp = inv_logit_scaled(betas1['munonExh_Intercept'])
both_ifp = 1 - (exh_ifp + nonExh_ifp) 
both_willq =  1 - (exh_willq + nonExh_willq)

# selecting only exhaustive situation more likely for QUD=willq than QUD=ifp
h4 = hypothesis(fit1, "muexh_Intercept + muexh_QUDwillq > muexh_Intercept")

# h1: when QUD=ifp, more likely to choose both than only exhaustive
# h2: when QUD=willq, more likely to choose exhaustive than both
# h3: more likely to choose both when QUD=ifp than when QUD=willq
samples = tidy_draws(fit1) %>% 
  transmute(p_exh_ifp = inv_logit_scaled(b_muexh_Intercept), 
         p_nonExh_ifp = inv_logit_scaled(b_munonExh_Intercept), 
         p_both_ifp = 1 - (p_exh_ifp + p_nonExh_ifp),
         
         p_exh_willq = inv_logit_scaled(b_muexh_Intercept + b_muexh_QUDwillq), 
         p_nonExh_willq = inv_logit_scaled(b_munonExh_Intercept + b_munonExh_QUDwillq), 
         p_both_willq = 1 - (p_exh_willq + p_nonExh_willq)
         ) %>% 
  mutate(h1 = p_both_ifp > p_exh_ifp,
         h2 = p_exh_willq > p_both_willq,
         h3 = p_both_ifp > p_both_willq, 
         h4 = p_exh_willq > p_exh_ifp)
samples %>% summarize(posterior_h1 = mean(h1), 
                      posterior_h2 = mean(h2),
                      posterior_h3 = mean(h3), 
                      posterior_h4 = mean(h4))
```


2. Predict selection based on QUD + stimulus

```{r}
model_path <- here(target_dir, "brms-model2.rds")
if(file.exists(model_path)) {
  fit2 <- readRDS(model_path)
} else {
fit2 <-
  brm(data = data.critical.model,
      family = categorical(link="logit"),
      response ~ 1 + picPair * QUD + (0 + picPair * QUD|submission_id),
      seed = 1)
saveRDS(fit2, file=model_path)
}
betas2 <- fixef(fit2)[, 'Estimate']
pp_check(fit2)
```

Consider picPairs separately

```{r, regression-hypotheses}
b = betas2
posterior_draws2 = tidy_draws(fit2) 
samples <- posterior_draws2 %>% 
  transmute(
    exh.willq_B = inv_logit_scaled(b_muexh_Intercept + b_muexh_QUDwillq +
      b_muexh_picPairB + `b_muexh_picPairB:QUDwillq`),
    exh.willq_D = inv_logit_scaled(b_muexh_Intercept + b_muexh_QUDwillq + 
      b_muexh_picPairD + `b_muexh_picPairD:QUDwillq`),
    exh.ifp_A = inv_logit_scaled(b_muexh_Intercept),
    exh.ifp_B = inv_logit_scaled(b_muexh_Intercept + b_muexh_picPairB),
    exh.ifp_C = inv_logit_scaled(b_muexh_Intercept + b_muexh_picPairC),
    exh.ifp_D = inv_logit_scaled(b_muexh_Intercept + b_muexh_picPairD),
    
    nonExh.willq_B = inv_logit_scaled(b_munonExh_Intercept + b_munonExh_QUDwillq +
      b_munonExh_picPairB + `b_munonExh_picPairB:QUDwillq`),
    nonExh.willq_D = inv_logit_scaled(b_munonExh_Intercept + b_munonExh_QUDwillq + 
      b_munonExh_picPairD + `b_munonExh_picPairD:QUDwillq`),
    nonExh.ifp_A = inv_logit_scaled(b_munonExh_Intercept),
    nonExh.ifp_B = inv_logit_scaled(b_munonExh_Intercept + b_munonExh_picPairB),
    nonExh.ifp_C = inv_logit_scaled(b_munonExh_Intercept + b_munonExh_picPairC),
    nonExh.ifp_D = inv_logit_scaled(b_munonExh_Intercept + b_munonExh_picPairD), 
    
    both.willq_B = 1 - exh.willq_B - nonExh.willq_B,
    both.willq_D = 1 - exh.willq_D - nonExh.willq_D,
    both.ifp_A = 1 - exh.ifp_A - nonExh.ifp_A,
    both.ifp_B = 1 - exh.ifp_B - nonExh.ifp_B,
    both.ifp_C = 1 - exh.ifp_C - nonExh.ifp_C,
    both.ifp_D = 1 - exh.ifp_D - nonExh.ifp_D
    ) %>% 
  # for each picPair:
  # h3: more likely to choose both when QUD=ifp than when QUD=willq
  # h4: more likely to choose exhaustive when QUD=willq than when QUD=ifp
  mutate(h3.B = both.ifp_B > both.willq_B,
         h3.D = both.ifp_D > both.willq_D,
         h4.B = exh.willq_B > exh.ifp_B,  
         h4.D = exh.willq_D > exh.ifp_D)

samples.long <- samples %>% pivot_longer(cols = everything(), 
                                         names_to = "condition", 
                                         values_to = "prediction") %>% 
  group_by(condition) %>% arrange(prediction)
posteriors = samples %>% 
  summarize(h3.B = mean(h3.B),
            h3.D = mean(h3.D),
            h4.B = mean(h4.B),
            h4.D = mean(h4.D))
posteriors
```

Predictions across picture pairs

```{r}
predictions.across_pic = tibble(
  exh.willq = samples %>% dplyr::select(starts_with("exh.willq")) %>% rowMeans(),
  exh.ifp =  samples %>% dplyr::select(starts_with("exh.ifp")) %>% rowMeans(),
  nonExh.willq =  samples %>% dplyr::select(starts_with("nonExh.willq")) %>% rowMeans(),
  nonExh.ifp =  samples %>% dplyr::select(starts_with("nonExh.ifp")) %>% rowMeans(),
  both.willq = samples %>% dplyr::select(starts_with("both.willq")) %>% rowMeans(),
  both.ifp = samples %>% dplyr::select(starts_with("both.ifp")) %>% rowMeans()
) %>% 
  mutate(h3 = both.ifp > both.willq,
         h4 = exh.willq > exh.ifp)

posteriors.across_pic = predictions.across_pic %>% 
  summarize(h3 = mean(h3), h4 = mean(h4))

df.empiric = data.critical.model %>% group_by(QUD, response) %>% 
  dplyr::count() %>% group_by(QUD) %>% 
  mutate(N=sum(n), prediction = n/N) %>% rename(selection = response) %>% 
  mutate(selection = as.factor(selection))

p.mainQUD = predictions.across_pic %>% dplyr::select(-h3, -h4) %>% 
  rowid_to_column() %>% 
  pivot_longer(cols=-rowid, names_to="condition", values_to="prediction") %>% 
  separate("condition", into=c("selection", "QUD")) %>% 
  mutate(QUD = as.factor(QUD), selection = as.factor(selection)) %>% 
  ggplot(aes(x=QUD, y=prediction, color = selection,
             group = interaction(QUD, selection))) + 
  geom_boxplot(outlier.shape = NA, width=0.9) +
  geom_point(data = df.empiric, shape = 23, size = 3, 
             aes(fill=selection), position = position_dodge(width = 0.9)) +
  labs(y = "posterior samples") +
  scale_x_discrete(labels = c(ifp = parse(text=TeX("$\\hat{\\theta}_{if-p}$")),
                              willq = parse(text=TeX("$\\hat{\\theta}_{will-q}$"))))
p.mainQUD
ggsave(file.path(plot_dir, "main-effect-question.pdf"), p.mainQUD, width=7, height=4)
```

3. Predict selection based on QUD, non-exhaustive and exhaustive situation

```{r, results='hide'}
model_path <- here(target_dir, "brms-model3.rds")
data.critical322 = data.critical.model %>% 
  dplyr::select(submission_id, picPair, QUD, response, RT, picPair.long, response) %>% 
    mutate(exh = case_when(picPair %in% c("A", "B") ~ "NoDistr",
                           picPair %in% c("C", "D") ~ "Distr"),
          nonExh = case_when(picPair %in% c("A", "C") ~ "internal",
                             picPair %in% c("B", "D") ~ "external"), 
          exh = factor(exh, levels = c("Distr", "NoDistr")), 
          nonExh = factor(nonExh, levels = c("external", "internal")))
if(file.exists(model_path)) {
  fit3 <- readRDS(model_path)
} else {
fit3 <-
  brm(data = data.critical322,
      family = categorical(link="logit"),
      response ~ 1 + exh * nonExh * QUD + (0 + exh * nonExh * QUD|submission_id),
      seed = 1)
  saveRDS(fit3, file=model_path)
}
betas3 <- fixef(fit3)[, 'Estimate']
pp_check(fit3)

```


# TODO

```{r}
h1 = hypothesis(fit, "questionifp < questionwillq", class = "b")
h2 = hypothesis(fit, "questionifp + exhNoDistr:questionifp < questionwillq + exhNoDistr:questionwillq", 
                class = "b")
h3 = hypothesis(fit, "questionifp + nonExhInternal:questionifp < questionwillq + nonExhInternal:questionwillq", 
                class = "b")
h4 = hypothesis(fit, 
  "questionifp + exhNoDistr:nonExhInternal:questionifp + exhNoDistr:nonExhInternal + exhNoDistr:questionifp + nonExhInternal:questionifp < questionwillq + exhNoDistr:nonExhInternal:questionwillq + exhNoDistr:nonExhInternal + exhNoDistr:questionwillq + nonExhInternal:questionwillq", class = "b")

h1$hypothesis
h2$hypothesis
h3$hypothesis
h4$hypothesis
```

```{r}
posterior_draws = tidy_draws(fit)
```

Estimated main effect of QUD across exhaustive/nonExhaustive realizations

```{r}
samples = posterior_draws %>% 
  mutate(
    neutral_D = b_Intercept,
    neutral_B = b_Intercept +  `b_exhNoDistr`,
    neutral_C = b_Intercept + b_nonExhInternal ,
    neutral_A = b_Intercept + b_nonExhInternal + `b_exhNoDistr` + `b_exhNoDistr:nonExhInternal`,
    
    ifp_D = b_Intercept + b_questionifp,
    ifp_B = b_Intercept + b_questionifp + `b_exhNoDistr` + `b_exhNoDistr:questionifp`,
    ifp_C = b_Intercept + b_questionifp + b_nonExhInternal + `b_nonExhInternal:questionifp`,
    ifp_A = b_Intercept + b_questionifp + b_nonExhInternal + b_exhNoDistr +
      `b_exhNoDistr:nonExhInternal` + `b_exhNoDistr:questionifp` + `b_nonExhInternal:questionifp` +
      `b_exhNoDistr:nonExhInternal:questionifp`,
    willq_D = b_Intercept + b_questionwillq,
    willq_B = b_Intercept + b_questionwillq + b_exhNoDistr + `b_exhNoDistr:questionwillq`,
    willq_C = b_Intercept + b_questionwillq + b_nonExhInternal + `b_nonExhInternal:questionwillq`,
    willq_A = b_Intercept + b_questionwillq + b_nonExhInternal + b_exhNoDistr +
      `b_exhNoDistr:nonExhInternal` + `b_exhNoDistr:questionwillq` + `b_nonExhInternal:questionwillq` +
      `b_exhNoDistr:nonExhInternal:questionwillq`)

coeffs = samples %>% 
  transmute(questionneutral = (neutral_D + neutral_B + neutral_C + neutral_A)/4,
            questionifp = (ifp_A + ifp_B + ifp_C + ifp_D)/4,
            questionwillq = (willq_A + willq_B + willq_C + willq_D)/4) %>% 
  mutate(ifpsmaller = questionifp < questionwillq)

# posterior probability
mean(coeffs$ifpsmaller)

means = coeffs %>% summarize(mean_neutral = mean(questionneutral),
                             mean_ifp = mean(questionifp),
                             mean_willq = mean(questionwillq))

# cohen.d(coeffs$questionifp, coeffs$questionwillq)
p.mainquestion = coeffs %>% rowid_to_column() %>% 
  pivot_longer(cols=c(questionneutral, questionifp, questionwillq)) %>%
  ggplot(aes(x=name, y=value)) + 
  geom_boxplot() +
  labs(x = "estimated coefficient", y = "posterior samples") +
  scale_x_discrete(labels = c(
    questionneutral = parse(text=TeX("$\\hat{\\beta}_{neutral}$")),
    questionifp = parse(text=TeX("$\\hat{\\beta}_{if-p}$")), 
    questionwillq = parse(text=TeX("$\\hat{\\beta}_{will-q}$")))
  )
p.mainquestion
ggsave(file.path(plot_dir, "main-effect-question.pdf"), p.mainquestion,
       width=7, height=4)
```

Estimated main effect of the exhaustive and the non-exhaustive situation 

```{r}
samples.exh = posterior_draws %>% 
  mutate(
    exhDistr_Eneutral = b_Intercept,
    exhDistr_Eifp = b_Intercept + b_questionifp,
    exhDistr_Ewillq = b_Intercept + b_questionwillq,
    exhDistr_Ineutral = b_Intercept + b_nonExhInternal,
    exhDistr_Iifp = b_Intercept + b_nonExhInternal + b_questionifp + `b_nonExhInternal:questionifp`,
    exhDistr_Iwillq = b_Intercept + b_nonExhInternal + b_questionwillq + `b_nonExhInternal:questionwillq`,
    
    `exhNoDistr_Eneutral` = b_Intercept + `b_exhNoDistr`,
    `exhNoDistr_Eifp` = b_Intercept + `b_exhNoDistr` + b_questionifp + `b_exhNoDistr:questionifp`,
    `exhNoDistr_Ewillq`= b_Intercept + `b_exhNoDistr` + b_questionwillq + `b_exhNoDistr:questionwillq`,
    `exhNoDistr_Ineutral` = b_Intercept + `b_exhNoDistr` + b_nonExhInternal + `b_exhNoDistr:nonExhInternal`,
    `exhNoDistr_Iifp` = b_Intercept + `b_exhNoDistr` + b_nonExhInternal + b_questionifp + 
      `b_nonExhInternal:questionifp` + `b_exhNoDistr:nonExhInternal` + `b_exhNoDistr:questionifp` + 
      `b_exhNoDistr:nonExhInternal:questionifp`,
    exhNoDistr_Iwillq = b_Intercept + `b_exhNoDistr` + b_nonExhInternal + b_questionwillq + 
      `b_nonExhInternal:questionwillq` + `b_exhNoDistr:nonExhInternal` + `b_exhNoDistr:questionwillq` + 
      `b_exhNoDistr:nonExhInternal:questionwillq`)

coeffs.exh = samples.exh %>% 
  transmute(exhDistr = (exhDistr_Eneutral + `exhDistr_Eifp` + `exhNoDistr_Ewillq` + 
                      `exhDistr_Ineutral` + exhDistr_Iifp + exhDistr_Iwillq)/6,
            exhNoDistr = (`exhNoDistr_Eneutral` + `exhNoDistr_Eifp` + `exhNoDistr_Ewillq` + 
                      `exhNoDistr_Ineutral` + `exhNoDistr_Iifp` + `exhNoDistr_Iwillq`)/6)
means = coeffs.exh %>% summarize(mean_exhDistr = mean(exhDistr), `mean_exhNoDistr` = mean(`exhNoDistr`))

mean(coeffs.exh$exhDistr > 0)
coeffs.exh %>% pivot_longer(cols=everything()) %>% 
  ggplot(aes(x=value, color=name)) + geom_density()
p.exh = coeffs.exh %>% rowid_to_column() %>% 
  pivot_longer(cols=c(exhDistr, `exhNoDistr`)) %>%
  ggplot(aes(x=name, y=value)) + 
  geom_boxplot() +
  labs(x = "estimated coefficient", y = "posterior samples") +
  scale_x_discrete(labels = c(
    exhE = parse(text=TeX("$\\hat{\\beta}_{exhDistr}$")),
    exhNoDistr = parse(text=TeX("$\\hat{\\beta}_{exhNoDistr}$"))
    )
  )
p.exh
ggsave(file.path(plot_dir, "main-effect-exhaustive.pdf"), p.exh, width=7, height=4)
```

1. non-exhaustive kept as external (1) and as internal (2): 
is there a difference between exhaustive = withDist or exhaustive = w/oDist ?

```{r}
# non-exhaustive: external
samples.exh %>% dplyr::select(exhDistr_Eneutral, `exhNoDistr_Eneutral`) %>% 
  transmute(`exhNoDistr_larger` = `exhNoDistr_Eneutral` > exhDistr_Eneutral) %>% 
  pull(`exhNoDistr_larger`) %>% mean()

# non-exhaustive: internal
samples.exh %>% dplyr::select(exhDistr_Ineutral, `exhNoDistr_Ineutral`) %>% 
  transmute(`exhNoDistr_larger` = `exhNoDistr_Ineutral` > exhDistr_Ineutral) %>% 
  pull(`exhNoDistr_larger`) %>% mean()
```

Estimated main effect of nonExhaustive realization

```{r}
samples.nonExh = posterior_draws %>% 
  mutate(
    nonExhE_Eneutral = b_Intercept,
    nonExhE_Eifp = b_Intercept + b_questionifp,
    nonExhE_Ewillq = b_Intercept + b_questionwillq,
    nonExhE_Ineutral = b_Intercept + b_exhNoDistr,
    nonExhE_Iifp = b_Intercept + b_exhNoDistr + b_questionifp + `b_exhNoDistr:questionifp`,
    nonExhE_Iwillq = b_Intercept + b_exhNoDistr + b_questionwillq + `b_exhNoDistr:questionwillq`,
    
    nonExhI_Eneutral = b_Intercept + b_nonExhInternal,
    nonExhI_Eifp = b_Intercept + b_nonExhInternal + b_questionifp + `b_nonExhInternal:questionifp`,
    nonExhI_Ewillq = b_Intercept + b_nonExhInternal + b_questionwillq + `b_nonExhInternal:questionwillq`,
    nonExhI_Ineutral = b_Intercept + b_exhNoDistr + b_nonExhInternal + `b_exhNoDistr:nonExhInternal`,
    nonExhI_Iifp = b_Intercept + b_exhNoDistr + b_nonExhInternal + b_questionifp + 
      `b_nonExhInternal:questionifp` + `b_exhNoDistr:nonExhInternal` + `b_exhNoDistr:questionifp` + 
      `b_exhNoDistr:nonExhInternal:questionifp`,
    nonExhI_Iwillq = b_Intercept + b_exhNoDistr + b_nonExhInternal + b_questionwillq + 
      `b_nonExhInternal:questionwillq` + `b_exhNoDistr:nonExhInternal` + `b_exhNoDistr:questionwillq` + 
      `b_exhNoDistr:nonExhInternal:questionwillq`)

coeffs.nonExh = samples.nonExh %>% 
  transmute(nonExhE = (nonExhE_Eneutral + nonExhE_Eifp + nonExhE_Ewillq + nonExhE_Ineutral + nonExhE_Iifp + nonExhE_Iwillq)/6,
            nonExhI = (nonExhI_Eneutral + nonExhI_Eifp + nonExhI_Ewillq + nonExhI_Ineutral + nonExhI_Iifp + nonExhI_Iwillq)/6)
means = coeffs.nonExh %>% 
  summarize(mean_nonExhE = mean(nonExhE), mean_nonExhI = mean(nonExhI))
coeffs.nonExh %>% pivot_longer(cols=everything()) %>% 
  ggplot(aes(x=value, color=name)) + geom_density()

p.nonExh = coeffs.nonExh %>% rowid_to_column() %>% 
  pivot_longer(cols=c(nonExhE, nonExhI)) %>%
  ggplot(aes(x=name, y=value)) + 
  geom_boxplot() +
  labs(x = "estimated coefficient", y = "posterior samples") +
  scale_x_discrete(labels = c(
    nonExhE = parse(text=TeX("$\\hat{\\beta}_{nonExhE}$")),
    nonExhI = parse(text=TeX("$\\hat{\\beta}_{nonExhI}$"))
    )
  )
p.nonExh
ggsave(file.path(plot_dir, "main-effect-nonExhaustive.pdf"), p.exh,
       width=7, height=4)
```

1. exhaustive:noDistr is very likely to yield a higher selection rate of the 
exhaustive picture when QUD is neutral.

2. exhaustive kept as Distr (1) and as NoDistr (2): is there a difference
between non-exhaustive = external or non-exhaustive = internal?

```{r}
# exhaustive: no Distractor
samples.nonExh %>% dplyr::select(nonExhE_Ineutral, nonExhI_Ineutral) %>% 
  transmute(nonExhE_larger = nonExhE_Ineutral > nonExhI_Ineutral) %>% 
  pull(nonExhE_larger) %>% mean()

# exhaustive: Distractor
samples.nonExh %>% dplyr::select(nonExhE_Eneutral, nonExhI_Eneutral) %>% 
  transmute(nonExhE_larger = nonExhE_Eneutral > nonExhI_Eneutral) %>% 
  pull(nonExhE_larger) %>% mean()
```

Estimated main effect of picture pairs

```{r}
samples.picPair = posterior_draws %>% 
  mutate(
    D = b_Intercept + (b_Intercept + b_questionifp) + (b_Intercept + b_questionwillq),
    C = b_Intercept + b_nonExhInternal + 
      (b_Intercept + b_nonExhInternal + b_questionifp + `b_nonExhInternal:questionifp`) +
      (b_Intercept + b_nonExhInternal + b_questionwillq + `b_nonExhInternal:questionwillq`),
    B = (b_Intercept + b_exhNoDistr) + 
      (b_Intercept + b_exhNoDistr + b_questionifp + `b_exhNoDistr:questionifp`) +
      (b_Intercept + b_exhNoDistr + b_questionwillq + `b_exhNoDistr:questionwillq`),
    A = (b_Intercept + b_exhNoDistr + b_nonExhInternal + `b_exhNoDistr:nonExhInternal`) +
      (b_Intercept + b_exhNoDistr + b_nonExhInternal + b_questionifp + 
      `b_nonExhInternal:questionifp` + `b_exhNoDistr:nonExhInternal` + `b_exhNoDistr:questionifp` + 
      `b_exhNoDistr:nonExhInternal:questionifp`) + 
      (b_Intercept + b_exhNoDistr + b_nonExhInternal + b_questionwillq + 
      `b_nonExhInternal:questionwillq` + `b_exhNoDistr:nonExhInternal` + `b_exhNoDistr:questionwillq` + 
      `b_exhNoDistr:nonExhInternal:questionwillq`)
  )

coeffs.picPair = samples.picPair %>% 
  transmute(D = D/3, C = C/3, B = B/3, A = A/3)
means = coeffs.picPair %>% 
  summarize(mean_D = mean(D), mean_C = mean(C), mean_B = mean(B), mean_A = mean(A))
coeffs.picPair %>% pivot_longer(cols=everything()) %>% 
  ggplot(aes(x=value, color=name)) + geom_density()

p.picPair = coeffs.picPair %>% rowid_to_column() %>% 
  pivot_longer(cols=c(D, C, B, A)) %>%
  ggplot(aes(x=name, y=value)) + 
  geom_boxplot() +
  labs(x = "estimated coefficient", y = "posterior samples") +
  scale_x_discrete(labels = c(
    A = parse(text=TeX("$\\hat{\\beta}_{A}$")),
    B = parse(text=TeX("$\\hat{\\beta}_{B}$")),
    C = parse(text=TeX("$\\hat{\\beta}_{C}$")),
    D = parse(text=TeX("$\\hat{\\beta}_{D}$"))
    )
  )
p.picPair
ggsave(file.path(plot_dir, "main-effect-picPair.pdf"), p.picPair, width=7, height=4)
```

# Reaction times

Look at reaction times split across all picture pairs

```{r}
critical.RT = data.critical %>% 
  dplyr::select(submission_id, QUD, RT, picPair.long, selected_pic, picPair.short) %>%
  mutate(visual_diff = case_when(picPair.short %in% c("B", "C") ~ T, 
                                 T ~ F)) %>% 
  group_by(QUD, picPair.long) 
critical.RT_means = critical.RT %>% 
  summarize(mean_RT = mean(RT), .groups = "drop_last")

bootstrap_RTs = group_map(critical.RT, function(df, df.group){
  bootstrap = map(seq(1, N), function(i){
    tibble(mean_RT = mean(sample(df$RT, n_participants, replace=T)))
  }) %>% bind_rows() %>% 
    add_column(picPair.long = df.group$picPair.long, QUD = df.group$QUD) %>% 
    arrange(mean_RT)
  
  CI.bounds = bootstrap_bounds(bootstrap)
  ci.low = bootstrap[CI.bounds[["low"]], ]$mean_RT
  ci.up = bootstrap[CI.bounds[["up"]], ]$mean_RT
  bootstrap %>% add_column(ci.low=ci.low, ci.up=ci.up)
}) %>% bind_rows() %>% group_by(picPair.long, QUD)

bootstrap_RTs.CI.question_pic = bootstrap_RTs %>%
  dplyr::select(-mean_RT) %>% distinct()

left_join(critical.RT_means, bootstrap_RTs.CI.question_pic) %>% 
  ggplot(aes(x=mean_RT, y=picPair.long, fill=QUD)) + 
  geom_bar(stat="identity", position = position_dodge()) + 
  geom_errorbar(aes(xmin=ci.low, xmax=ci.up), position = position_dodge())# +
```

```{r}
p.rt = critical.RT %>%
  ggplot(aes(x=log(RT), color=picPair.long)) + geom_density() +
  guides(color = guide_legend(ncol=2))  +
  scale_color_brewer(name = "stimulus", palette = "Set2")

p.rt
p.rt + facet_wrap(~QUD)
ggsave(file.path(plot_dir, "empiric-rts.pdf"), p.rt, width=7, height=4)
```

```{r}
df.rt = critical.RT %>% 
  dplyr::select(submission_id, QUD, RT, picPair.long, picPair.short) %>% 
  #filter(!submission_id %in% ids.scores) %>% 
  separate(col = picPair.long, into = c("exh_situation", "nonExh_situation"), sep="-") %>% 
  mutate(exh_situation = str_sub(exh_situation, start=4),
         exh_situation = factor(exh_situation, 
                                levels = c("withDistractor", "w/oDistractor")))

df.rt_means = df.rt %>% 
  group_by(QUD, exh_situation, nonExh_situation, picPair.short) %>% 
  summarize(mean_rt = mean(RT), .groups = "drop_last")

p <- df.rt_means %>% ggplot(aes(x=exh_situation, y=mean_rt, color=nonExh_situation)) +
  geom_point(aes(shape = QUD)) +
  geom_line(aes(group=interaction(QUD, nonExh_situation))) +
  labs(y = "average reaction time", x = "exhaustive situation") +
  scale_color_brewer(name = "non-exhaustive situation", palette = "Set2")
  # annotate("text", x=rep("withDistractor", 2), y=c(14000, 16000), 
  #               label=c("C", "D"), hjust=2) +
  # annotate("text", x=rep("w/oDistractor", 2), y=c(13500, 15500), 
  #               label=c("A", "B"), hjust=-2)
p 
ggsave(file.path(plot_dir, "reaction-times-233.pdf"), p, width=7, height=4)

```


# TODO: model rts
When the non-exhaustive picture is external (B + D) participants seem to respond 
more slowly than when the non-exhaustive picture is internal (A + C), when 
question=ifp or question=willq.


```{r}
# model_path = here("results", "brms-model-rts233.rds")
# if(file.exists(model_path)) {
#   fit_rt <- readRDS(model_path)
# } else {
#   fit_rt <- brm(
#     data = df.rt %>% 
#       rename(exh=exh_situation, nonExh=nonExh_situation, picPair=picPair.short),
#     family = lognormal(),
#     # RT ~ 1 + exh * nonExh * question + (1 + exh + nonExh + question|submission_id),
#     RT ~ 1 + picPair * question + (1 + picPair + question | submission_id),
#     seed = 1, control = list(adapt_delta = 0.99), iter = 4000
#   )
#   saveRDS(fit_rt, file=model_path)
# }
# fixef(fit_rt)
# pp_check(fit_rt)
# mcmc_plot(fit_rt)
# 
# pp_check(fit_rt, type = "stat", stat = 'mean', nsamples = 100)

```
