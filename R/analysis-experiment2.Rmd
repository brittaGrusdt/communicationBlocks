---
title: "analysis"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(brms)
library(here)
library(latex2exp)
library(tidybayes)
library(tidyverse)
source(here("R", "utils.R"))

theme_set(theme_minimal(base_size=12) + theme(legend.position = "top"))
target_dir = here("results", "experiment2", "pretests")
plot_dir = file.path(target_dir, "figs")
if(!file.exists(plot_dir)) dir.create(plot_dir, recursive = TRUE)
```

Load experimental data

```{r}
fn <- file.path(target_dir, "results_82_CommunicationBlocks2_BG-6.csv")
data <- read.csv(fn, sep=",") %>% as_tibble() %>% group_by(submission_id)
```

Sanity checks
pic1, pic2, pic3 is the same for all participants (but occur in random order)

```{r}
N = data$submission_id %>% unique() %>% length()
data %>% ungroup %>% select(id, type, pic1, pic2, pic3) %>% 
  group_by_all() %>% 
  dplyr::count() %>% filter(n != N)
```

## Attention-check for Prolific

1. Filter out participants who did not get attention checks right

```{r}
attention_checks = data %>% filter(type=="attention-check") %>% 
  dplyr::select(submission_id, id, selected_pic, expected, comments) %>% 
  mutate(correct = case_when(expected == selected_pic ~ TRUE, T ~ FALSE)) 

ids.attention_out = attention_checks %>% filter(expected != selected_pic) %>% 
  dplyr::select(submission_id, comments) %>% distinct()

attention_checks %>% group_by(correct) %>% dplyr::count()
ids.attention_out
```

2. How often did each participant select a contrast picture? Or all three pics?

```{r}
data.test = data %>% filter(str_detect(trial_name, "image_selection"))
df.selected_pics = data.test %>% select(submission_id, response, id, type) %>% 
  mutate(response = case_when(length(str_split(response, "_")[[1]]) == 3 ~ "all", 
                              T ~ response))

ids.select3 = df.selected_pics %>% filter(response == "all")
ids.select3

df.ids.contrast = df.selected_pics %>% filter(str_detect(response, "contrast"))
df.ids.contrast
```

3. Look at participants' responses to questions shown in the end

```{r}
data %>% dplyr::select(submission_id, check_ann) %>% 
  distinct() %>% group_by(check_ann) %>% dplyr::count()
data %>% dplyr::select(submission_id, check_behavior) %>% distinct()
```

4. Participants' comments

```{r}
data %>% select(comments, submission_id, prolific_id) %>% distinct()
```


## Load cleaned data 

Data was cleaned (see script clean_data.R) according to predefined exclusion criteria

```{r, message=FALSE}
# TODO: write clean_data_exp2()
# data = read_csv(here("results", "data_cleaned.csv"))
```

Trials where a pragmatic and a literal selection is possible

```{r}
trials_lit_prag = c("trial7", "trial8", "trial19", "trial20", "trial21", "trial24")
df <- data %>% filter(id %in% trials_lit_prag) %>% 
  dplyr::select(submission_id, response, type, id, response)

# by trials
df %>% group_by(id) %>% 
  ggplot(aes(x=id, fill=response)) + 
  geom_bar(stat="count", position=position_dodge())

pic_props = data.test %>% ungroup() %>% 
  select(starts_with("property_"), type, id) %>% 
  unite(col="props", "property_pic1", "property_pic2", "property_pic3", sep="_") %>% 
  distinct() %>% arrange(type)

pic_props %>% filter(id %in% trials_lit_prag)
```

Practice trials

```{r}
data.practice = data.test %>% filter(type == "practice") %>% 
   dplyr::select(submission_id, response, id)

data.practice %>% ggplot(aes(x=id, fill=response)) + 
  geom_bar(stat="count", position=position_dodge())

pic_props %>% filter(type == "practice")
```

Trials, where a selection of one is risky since no clue for neither of both
Trial11 is a practice trial, trial13 a filler trial.

```{r}
risk_trials = c("trial11", "trial13")
data.risk <- data %>% filter(id %in% risk_trials) %>% 
  dplyr::select(submission_id, response, id, type)

data.risk %>% ggplot(aes(x=id, fill=response)) + 
  geom_bar(stat="count", position=position_dodge())
pic_props %>% filter(id %in% risk_trials)
```

## Meta information about participants

```{r, meta, echo=FALSE}
data.meta <- data %>% 
  distinct_at(vars(c(submission_id)), .keep_all = T) %>%
  mutate(education=as_factor(education), gender=as_factor(gender))

data.meta$gender %>% summary()
data.meta$education %>% summary()
print("age:")
data.meta$age %>% summary()
print("timeSpent:")
data.meta$timeSpent %>% summary()
```

## Plot critical trials

```{r}
QUDs = c(netural = "Which blocks do you think will fall?",
         ifp = "What happens if the 'antecedent-block' falls?",
         willq = "Will the 'consequent-block' fall?")
```

```{r, data-critical, echo=FALSE}
data.critical = data %>% 
  filter(type=="critical") %>% 
  select(submission_id, id, type, QUD, response, selected_pic, pic2, pic3, RT) %>% 
  mutate(pic2=str_replace(pic2, ".png", ""), pic2=str_replace(pic2, "_horiz", ""),
         pic3 = str_replace(pic3, ".png", ""), pic3=str_replace(pic3, "_horiz", "")) %>% 
  mutate(picPair=paste(pic2, pic3, sep=" & "),
         picPair.long = 
           case_when(picPair == "if2_unn & if2_unu" ~ "D. withDistractor-external", 
                     picPair == "if1_un & if2_unu" ~ "B. w/oDistractor-external",
                     picPair == "if1_un & if1_uu" ~ "A. w/oDistractor-internal",
                     picPair == "if2_unn & if1_uu" ~ "C. withDistractor-internal")) %>% 
  dplyr::select(-pic2, -pic3) %>%
  mutate(picPair.short = substr(picPair.long, 1, 1))

# by QUD
data.critical %>% group_by(QUD, response) %>% 
  summarize(n=n(), .groups = "drop_last") %>% 
  mutate(ratio = n / sum(n)) %>% 
  ggplot(aes(fill=response, y=QUD, x=ratio)) + 
  geom_bar(stat="identity", position=position_dodge(preserve = 'single'))

# by trial
data.critical %>% group_by(picPair.long, QUD, response) %>% 
  summarize(n=n(), .groups = "drop_last") %>% 
  mutate(ratio = n / sum(n)) %>% 
  ggplot(aes(fill=response, y=QUD, x=ratio)) + 
  geom_bar(stat="identity", position=position_dodge(preserve = 'single')) +
  facet_wrap(~picPair.long, scales = "free")
```

Results with 95%-bootstrap confidence intervals

```{r, boostrap-samples, echo = FALSE}
N = 1000
n_participants = data.critical$submission_id %>% unique() %>% length()
CI_bounds = c(low = ceiling(0.025 * N), up = ceiling(0.975 * N))

responses = c("exhaustive", "non-exhaustive", "exhaustive_non-exhaustive")
df.critical = data.critical %>% 
  dplyr::select(submission_id, picPair.long, picPair.short, QUD, response) %>% 
  group_by(picPair.long, QUD)

res.not_occurring = tibble(response = responses, n=0)

bootstrap_samples = group_map(df.critical, function(df, df.group) {
  bootstrap = map(seq(1, N), function(i){
    samples = tibble(response = sample(df$response, n_participants, replace=T)) %>%
      group_by(response) %>% summarize(n=n()) %>%
      mutate(n = n/sum(n))
    bind_rows(samples, res.not_occurring) %>% 
      distinct_at(vars(c(response)), .keep_all = T) %>%
      rename(ratio = n)
    }) %>% bind_rows() %>% 
    add_column(picPair.long = df.group$picPair.long, QUD = df.group$QUD) %>% 
    group_by(picPair.long, QUD, response) %>% arrange(ratio) %>% 
    mutate(idx = row_number())
  
  bootstrap %>% mutate(ci_low = case_when(idx == CI_bounds[["low"]] ~ T, 
                                          T ~ F), 
                       ci_up = case_when(idx == CI_bounds[["up"]] ~ T, 
                                         T ~ F)) 
}) %>% bind_rows() %>% group_by(picPair.long, QUD)

CI.low = bootstrap_samples %>% filter(ci_low) %>% select(-idx, -ci_low, -ci_up) %>% 
  rename(ci.low = ratio)
CI.up = bootstrap_samples %>% filter(ci_up) %>% select(-idx, -ci_low, -ci_up) %>% 
  rename(ci.up = ratio)
CIs = left_join(CI.low, CI.up)

# TODO: save bootstrapped data (use built-in bootstrap function?)
```

```{r, critical-data-rates, echo = FALSE}
data.critical.rate = df.critical %>% 
  group_by(picPair.long, picPair.short, QUD, response) %>% 
  summarize(n=n(), .groups = "drop_last") %>% 
  mutate(ratio = n/sum(n))

data.critical.rate = left_join(
  data.critical.rate,
  CIs, 
  by=c("QUD", "picPair.long", "response")
)
```

1. across all different instantiations, i.e. exhaustive/non-exhaustive 
picture combinations

```{r}
conditions = configure(c("QUDs"))
data.critical %>%
  ggplot(aes(fill=response, y=QUD)) + 
  geom_bar(position=position_dodge(preserve = 'single')) +
  scale_y_discrete(breaks=names(conditions), labels = conditions) + 
  labs(y="Ann's question") +
  guides(fill = guide_legend(ncol = 2))

# same plot with exhaustive-picture selection ratios instead of absolute numbers
data.critical.rate %>% group_by(QUD, response) %>% 
  mutate(ratio = mean(ratio)) %>% distinct_at(vars(c(QUD, response)), .keep_all = T) %>% 
  ggplot(aes(x=ratio, y=QUD, fill=response, group = response)) + 
  geom_bar(stat="identity", position = position_dodge()) + 
  geom_errorbar(aes(xmin=ci.low, xmax=ci.up), 
                position = position_dodge()) +
  geom_text(aes(label=round(ratio, 2)), hjust=-0.25, vjust=-0.45, color = 'blue',
            position = position_dodge(width = .9)) +
  scale_y_discrete(breaks=names(conditions), labels = conditions) + 
  labs(y="Ann's question", x="selection rate") +
  guides(fill = guide_legend(ncol = 2))
```

2. split among different instantiations of critical trials 
(i.e., across different picture combinations)

```{r}
p = data.critical.rate %>% 
  mutate(condition = factor(picPair.long), 
         QUD = case_when(QUD == "willq" ~ "will-q",
                         QUD == "ifp" ~ "if-p", 
                         T ~ QUD),
         QUD = as.factor(QUD)) %>% 
  ggplot(aes(x=ratio, y=QUD, fill=response, group=response)) + 
  geom_bar(stat="identity", position = position_dodge()) + 
  geom_errorbar(aes(xmin=ci.low, xmax=ci.up), position = position_dodge()) +
  geom_text(aes(label=round(ratio, 2)), hjust=-0.25, vjust=-0.3,
            position = position_dodge(width = .9), color='blue') +
  facet_wrap(~condition) + 
  labs(x="selection rate", y = "QUD")
p
ggsave(here(plot_dir, "selection-rates.pdf"), p, width=7, height=4)
```

## Bayesian regression model

```{r, results='hide'}
# model_path = here(target_dir, "brms-model.rds")
# data.critical.model = data.critical %>% rename(picPair.full = picPair,
#                                                picPair = picPair.short)
# if(file.exists(model_path)) {
#   fit <- readRDS(model_path)
# } else {
#   fit <-
#     brm(data = data.critical.model,
#         family = bernoulli,
#         y ~ 1 + picPair * question + (1 + picPair + question|submission_id),
#         seed = 1)
#   saveRDS(fit, file=model_path)
# }
# fixef(fit)
# pp_check(fit)
# mcmc_plot(fit)
# 
# pp_check(fit, type = "stat", stat = 'mean', nsamples = 100)
```

Testing our hypotheses

1. separately for each picture pair

```{r, regression-hypotheses}
# h1 = hypothesis(fit, "questionifp < questionwillq", class = "b")
# h2 = hypothesis(fit, "questionifp + picPairB:questionifp < questionwillq + picPairB:questionwillq", class = "b")
# h3 = hypothesis(fit, "questionifp + picPairC:questionifp < questionwillq + picPairC:questionwillq", class = "b")
# h4 = hypothesis(fit, "questionifp + picPairD:questionifp < questionwillq + picPairD:questionwillq", class = "b")
# 
# h1$hypothesis
# h2$hypothesis
# h3$hypothesis
# h4$hypothesis
```

2. Across picture pairs

```{r}
# samples = tidy_draws(fit) %>% 
#   mutate(
#     ifp_A = b_Intercept + b_questionifp,
#     ifp_B = b_Intercept + b_questionifp + b_picPairB + `b_picPairB:questionifp`,
#     ifp_C = b_Intercept + b_questionifp + b_picPairC + `b_picPairC:questionifp`,
#     ifp_D = b_Intercept + b_questionifp + b_picPairD + `b_picPairD:questionifp`,
#     willq_A = b_Intercept + b_questionwillq,
#     willq_B = b_Intercept + b_questionwillq + b_picPairB + `b_picPairB:questionwillq`,
#     willq_C = b_Intercept + b_questionwillq + b_picPairC + `b_picPairC:questionwillq`,
#     willq_D = b_Intercept + b_questionwillq + b_picPairD + `b_picPairD:questionwillq`)
# 
# coeffs = samples %>% 
#   transmute(questionifp = (ifp_A + ifp_B + ifp_C + ifp_D)/4,
#             questionwillq = (willq_A + willq_B + willq_C + willq_D)/4) %>% 
#   mutate(ifpsmaller = questionifp < questionwillq)
# 
# mean(coeffs$ifpsmaller)
# 
# means = coeffs %>% summarize(mean_ifp = mean(questionifp),
#                              mean_willq = mean(questionwillq))
# 
# 
# # cohen.d(coeffs$questionifp, coeffs$questionwillq)
# p.mainquestion = coeffs %>% rowid_to_column() %>% 
#   pivot_longer(cols=c(questionifp, questionwillq)) %>%
#   ggplot(aes(x=name, y=value)) + 
#   geom_boxplot() +
#   # geom_point(aes(group=rowid), alpha=0.1, width=0.2, height=0) +
#   # geom_line(aes(group=rowid), alpha=0.1) + 
#   labs(x = "estimated coefficient", y = "posterior samples") +
#   scale_x_discrete(labels = c(questionifp = parse(text=TeX("$\\hat{\\beta}_{if-p}$")), 
#                               questionwillq = parse(text=TeX("$\\hat{\\beta}_{will-q}$"))))
# ggsave(file.path(plot_dir, "main-effect-question.pdf"), p.mainquestion, width=7, height=4)
```

Analysis with 3x2x2 design

```{r}
get_responses_all_QUDs = function(dat){
  df = dat %>% group_by(submission_id, picPair.long, picPair.short) %>% 
    dplyr::select(submission_id, picPair.long, picPair.short, QUD, response)

  df.wide = df %>% group_by(picPair.long, picPair.short, submission_id) %>% 
    mutate(response = str_replace(response, "non-exhaustive", "nonExh"), 
           response = str_replace(response, "exhaustive", "exh")) %>% 
    pivot_wider(names_from = QUD, values_from = response, values_fill = "-") %>% 
    unite("ifp.willq", ifp, willq, sep="/") %>% 
    mutate(ifp.willq = factor(ifp.willq, 
                              levels = c("exh/-", # if-p: exh
                                         "nonExh/-", # if-p: nonExh
                                         "exh_nonExh/-", #if-p: exh and nonExh
                                         "exh/exh", # if-p and will-q: exh
                                         "exh_nonExh/exh_nonExh", # ...
                                         "exh_nonExh/exh"),
                              labels = c("e/-", "n/-", "e_n/-", "e/e", 
                                         "e_n/e_n", "e_n/e")),
           stimulus = picPair.long) %>% 
    separate(picPair.long, into = c("exh", "nonExh"), sep = "-") %>%
    separate(exh, into = c("tmp", "exh"), sep=". ") %>% select(-tmp) %>% 
    rename(response = ifp.willq)
  return(df.wide)
}

plot_responses_all_QUDs = function(dat) {
  df.wide <- get_responses_all_QUDs(dat)
  df.wide.count = df.wide %>% group_by(stimulus, picPair.short, response) %>% 
    dplyr::count() %>% group_by(stimulus) %>% mutate(N=sum(n), ratio=n/N)
  
  xlab = "selected situation for both QUDs: if-p/will-q"
  p <- df.wide.count %>% ggplot(aes(x=response, y=ratio , fill=response)) + 
    geom_bar(stat="identity", position=position_dodge()) +
    geom_label(aes(label=n)) +
    scale_fill_brewer(palette='Set2', name="response ifp_willq") +
    facet_wrap(~stimulus, nrow = 2) +
    theme(legend.position = "none") +
    labs(y = "number participants", x=xlab)
  return(p)
}
p <- plot_responses_all_QUDs(data.critical)
p
ggsave(file.path(plot_dir, "empirical-responses.pdf"), p, width=7, height=4)
```

Score participants: for the two critical stimuli that occur with both QUDs 
(B + D), participants receive 1 point if they differentiate the QUDs ifp_willq, 
i.e. when they choose the exhaustive picture for one QUD and the non-exhaustive
for the other (independent of direction).
A score of 0 then means that the respective participant never made a difference 
between the two quds and a score of two that participant always made a difference
between them.

```{r}
responses.all_quds = get_responses_all_QUDs(data.critical) %>% 
  separate("response", into = c("ifp", "willq"), sep="/") %>% 
  mutate(score = case_when(ifp == willq ~ 0, T ~ 1)) %>% filter(willq != "-") 

df.scores = responses.all_quds %>% group_by(submission_id) %>%
  summarize(score.total=sum(score))
df.scores %>% ggplot(aes(x=score.total)) + geom_bar() +
  labs(x="nb times participants gave different answers for different QUDs")

ids.scores12 <- df.scores %>% filter(score.total <= 2 & score.total >= 1) %>% 
  pull(submission_id)
plot_empirical(data.critical %>% filter(submission_id %in% ids.scores12)) +
  ggtitle("Participants with 0 or 1 ignorance of QUD")

# those who never take QUD into account, do they switch between exh-exh and nonExh-nonExh
# or always give the same (identical) answer?
ids.score0 = df.scores %>% filter(score.total == 0) %>% pull(submission_id)
df.ignored_qud = responses.all_quds %>% filter(submission_id %in% ids.score0) %>% 
  group_by(submission_id, ifp, willq) %>% 
  dplyr::count(name="nb_stimuli") %>%
  arrange(submission_id) %>% 
  rename(selection = ifp) %>% ungroup() %>% dplyr::select(-willq)

df.ignored_qud
```

Plot empirical selection rates

```{r}
df <- data.critical.rate %>% 
  mutate(condition = factor(picPair.long), 
         QUD = case_when(QUD == "willq" ~ "will-q",
                         QUD == "ifp" ~ "if-p", 
                         T ~ QUD),
         QUD = as.factor(QUD)) %>% 
  separate(col = picPair.long, into = c("exh_situation", "nonExh_situation"), sep="-") %>%
  mutate(exh_situation = str_sub(exh_situation, start=4),
         exh_situation = factor(exh_situation, levels = c("withDistractor", "w/oDistractor")))

w_dodge = 0.25
p <- df %>% mutate(response = str_replace(response, "non-exhaustive", "nonExh"),
                   response = str_replace(response, "exhaustive", "exh")) %>% 
  ggplot(aes(x=picPair.short, y=ratio, shape = QUD, color = response)) +
             #group=interaction(QUD, nonExh_situation))) +
  geom_point(position = position_dodge(width=w_dodge)) +
  geom_errorbar(aes(ymin=ci.low, ymax=ci.up), width=0.1, 
                position = position_dodge(width=w_dodge)) +
  #geom_line(position = position_dodge(width=w_dodge)) +
  #labs(y = "selection rates", x = "exhaustive situation") +
  labs(x="stimulus", y="selection rate") +
  scale_color_brewer(name = "selection", palette = "Set2") +
  guides(color = guide_legend(title.position="top"), shape = guide_legend(title.position="top"))

p
ggsave(file.path(plot_dir, "empirical-responses-rates-bypic.pdf"), p, width=7, height=4)

p <- df %>% mutate(response = str_replace(response, "non-exhaustive", "nonExh"),
                   response = str_replace(response, "exhaustive", "exh")) %>% 
  ggplot(aes(x=exh_situation, y=ratio, shape = QUD, color = nonExh_situation, 
             group=interaction(QUD, nonExh_situation))) +
  geom_point(position = position_dodge(width=w_dodge)) +
  geom_errorbar(aes(ymin=ci.low, ymax=ci.up), width=0.1, 
                position = position_dodge(width=w_dodge)) +
  geom_line(position = position_dodge(width=w_dodge)) +
  labs(y = "selection rates", x = "exhaustive situation") +
  scale_color_brewer(name = "selection", palette = "Set2") +
  guides(color = guide_legend(title.position="top"), shape = guide_legend(title.position="top")) +
  facet_wrap(~response)
p
ggsave(file.path(plot_dir, "empirical-responses-rates-233.pdf"), p, width=7, height=4)

```
# TODO model

```{r, results='hide'}
model_path = file.path(target_dir, "brms-model-3x2x2.rds")
data.critical322 = data.critical.model

data.critical322 = data.critical322 %>% 
  dplyr::select(submission_id, picPair, question, response, RT, picPair.long, y) %>% 
    mutate(exh = case_when(picPair %in% c("A", "B") ~ "NoDistr",
                                     picPair %in% c("C", "D") ~ "Distr"),
          nonExh = case_when(picPair %in% c("A", "C") ~ "Internal",
                             picPair %in% c("B", "D") ~ "External"), 
          exh = factor(exh, levels = c("Distr", "NoDistr")), 
          nonExh = factor(nonExh, levels = c("External", "Internal")))
if(file.exists(model_path)) {
  fit <- readRDS(model_path)
} else {
  fit <-
    brm(data = data.critical322,
        family = bernoulli,
        y ~ 1 +  exh * nonExh * question + (1 + exh + nonExh + question|submission_id),
        seed = 1, iter = 6000)
  saveRDS(fit, file=model_path)
}
fixef(fit)
pp_check(fit)
mcmc_plot(fit)

pp_check(fit, type = "stat", stat = 'mean', nsamples = 100)
```

```{r}
h1 = hypothesis(fit, "questionifp < questionwillq", class = "b")
h2 = hypothesis(fit, "questionifp + exhNoDistr:questionifp < questionwillq + exhNoDistr:questionwillq", 
                class = "b")
h3 = hypothesis(fit, "questionifp + nonExhInternal:questionifp < questionwillq + nonExhInternal:questionwillq", 
                class = "b")
h4 = hypothesis(fit, 
  "questionifp + exhNoDistr:nonExhInternal:questionifp + exhNoDistr:nonExhInternal + exhNoDistr:questionifp + nonExhInternal:questionifp < questionwillq + exhNoDistr:nonExhInternal:questionwillq + exhNoDistr:nonExhInternal + exhNoDistr:questionwillq + nonExhInternal:questionwillq", class = "b")

h1$hypothesis
h2$hypothesis
h3$hypothesis
h4$hypothesis
```

```{r}
posterior_draws = tidy_draws(fit)
```

Estimated main effect of QUD across exhaustive/nonExhaustive realizations

```{r}
samples = posterior_draws %>% 
  mutate(
    neutral_D = b_Intercept,
    neutral_B = b_Intercept +  `b_exhNoDistr`,
    neutral_C = b_Intercept + b_nonExhInternal ,
    neutral_A = b_Intercept + b_nonExhInternal + `b_exhNoDistr` + `b_exhNoDistr:nonExhInternal`,
    
    ifp_D = b_Intercept + b_questionifp,
    ifp_B = b_Intercept + b_questionifp + `b_exhNoDistr` + `b_exhNoDistr:questionifp`,
    ifp_C = b_Intercept + b_questionifp + b_nonExhInternal + `b_nonExhInternal:questionifp`,
    ifp_A = b_Intercept + b_questionifp + b_nonExhInternal + b_exhNoDistr +
      `b_exhNoDistr:nonExhInternal` + `b_exhNoDistr:questionifp` + `b_nonExhInternal:questionifp` +
      `b_exhNoDistr:nonExhInternal:questionifp`,
    willq_D = b_Intercept + b_questionwillq,
    willq_B = b_Intercept + b_questionwillq + b_exhNoDistr + `b_exhNoDistr:questionwillq`,
    willq_C = b_Intercept + b_questionwillq + b_nonExhInternal + `b_nonExhInternal:questionwillq`,
    willq_A = b_Intercept + b_questionwillq + b_nonExhInternal + b_exhNoDistr +
      `b_exhNoDistr:nonExhInternal` + `b_exhNoDistr:questionwillq` + `b_nonExhInternal:questionwillq` +
      `b_exhNoDistr:nonExhInternal:questionwillq`)

coeffs = samples %>% 
  transmute(questionneutral = (neutral_D + neutral_B + neutral_C + neutral_A)/4,
            questionifp = (ifp_A + ifp_B + ifp_C + ifp_D)/4,
            questionwillq = (willq_A + willq_B + willq_C + willq_D)/4) %>% 
  mutate(ifpsmaller = questionifp < questionwillq)

# posterior probability
mean(coeffs$ifpsmaller)

means = coeffs %>% summarize(mean_neutral = mean(questionneutral),
                             mean_ifp = mean(questionifp),
                             mean_willq = mean(questionwillq))

# cohen.d(coeffs$questionifp, coeffs$questionwillq)
p.mainquestion = coeffs %>% rowid_to_column() %>% 
  pivot_longer(cols=c(questionneutral, questionifp, questionwillq)) %>%
  ggplot(aes(x=name, y=value)) + 
  geom_boxplot() +
  labs(x = "estimated coefficient", y = "posterior samples") +
  scale_x_discrete(labels = c(
    questionneutral = parse(text=TeX("$\\hat{\\beta}_{neutral}$")),
    questionifp = parse(text=TeX("$\\hat{\\beta}_{if-p}$")), 
    questionwillq = parse(text=TeX("$\\hat{\\beta}_{will-q}$")))
  )
p.mainquestion
ggsave(file.path(plot_dir, "main-effect-question.pdf"), p.mainquestion,
       width=7, height=4)
```

Estimated main effect of the exhaustive and the non-exhaustive situation 

```{r}
samples.exh = posterior_draws %>% 
  mutate(
    exhDistr_Eneutral = b_Intercept,
    exhDistr_Eifp = b_Intercept + b_questionifp,
    exhDistr_Ewillq = b_Intercept + b_questionwillq,
    exhDistr_Ineutral = b_Intercept + b_nonExhInternal,
    exhDistr_Iifp = b_Intercept + b_nonExhInternal + b_questionifp + `b_nonExhInternal:questionifp`,
    exhDistr_Iwillq = b_Intercept + b_nonExhInternal + b_questionwillq + `b_nonExhInternal:questionwillq`,
    
    `exhNoDistr_Eneutral` = b_Intercept + `b_exhNoDistr`,
    `exhNoDistr_Eifp` = b_Intercept + `b_exhNoDistr` + b_questionifp + `b_exhNoDistr:questionifp`,
    `exhNoDistr_Ewillq`= b_Intercept + `b_exhNoDistr` + b_questionwillq + `b_exhNoDistr:questionwillq`,
    `exhNoDistr_Ineutral` = b_Intercept + `b_exhNoDistr` + b_nonExhInternal + `b_exhNoDistr:nonExhInternal`,
    `exhNoDistr_Iifp` = b_Intercept + `b_exhNoDistr` + b_nonExhInternal + b_questionifp + 
      `b_nonExhInternal:questionifp` + `b_exhNoDistr:nonExhInternal` + `b_exhNoDistr:questionifp` + 
      `b_exhNoDistr:nonExhInternal:questionifp`,
    exhNoDistr_Iwillq = b_Intercept + `b_exhNoDistr` + b_nonExhInternal + b_questionwillq + 
      `b_nonExhInternal:questionwillq` + `b_exhNoDistr:nonExhInternal` + `b_exhNoDistr:questionwillq` + 
      `b_exhNoDistr:nonExhInternal:questionwillq`)

coeffs.exh = samples.exh %>% 
  transmute(exhDistr = (exhDistr_Eneutral + `exhDistr_Eifp` + `exhNoDistr_Ewillq` + 
                      `exhDistr_Ineutral` + exhDistr_Iifp + exhDistr_Iwillq)/6,
            exhNoDistr = (`exhNoDistr_Eneutral` + `exhNoDistr_Eifp` + `exhNoDistr_Ewillq` + 
                      `exhNoDistr_Ineutral` + `exhNoDistr_Iifp` + `exhNoDistr_Iwillq`)/6)
means = coeffs.exh %>% summarize(mean_exhDistr = mean(exhDistr), `mean_exhNoDistr` = mean(`exhNoDistr`))

mean(coeffs.exh$exhDistr > 0)
coeffs.exh %>% pivot_longer(cols=everything()) %>% 
  ggplot(aes(x=value, color=name)) + geom_density()
p.exh = coeffs.exh %>% rowid_to_column() %>% 
  pivot_longer(cols=c(exhDistr, `exhNoDistr`)) %>%
  ggplot(aes(x=name, y=value)) + 
  geom_boxplot() +
  labs(x = "estimated coefficient", y = "posterior samples") +
  scale_x_discrete(labels = c(
    exhE = parse(text=TeX("$\\hat{\\beta}_{exhDistr}$")),
    exhNoDistr = parse(text=TeX("$\\hat{\\beta}_{exhNoDistr}$"))
    )
  )
p.exh
ggsave(file.path(plot_dir, "main-effect-exhaustive.pdf"), p.exh, width=7, height=4)
```

1. non-exhaustive kept as external (1) and as internal (2): 
is there a difference between exhaustive = withDist or exhaustive = w/oDist ?

```{r}
# non-exhaustive: external
samples.exh %>% dplyr::select(exhDistr_Eneutral, `exhNoDistr_Eneutral`) %>% 
  transmute(`exhNoDistr_larger` = `exhNoDistr_Eneutral` > exhDistr_Eneutral) %>% 
  pull(`exhNoDistr_larger`) %>% mean()

# non-exhaustive: internal
samples.exh %>% dplyr::select(exhDistr_Ineutral, `exhNoDistr_Ineutral`) %>% 
  transmute(`exhNoDistr_larger` = `exhNoDistr_Ineutral` > exhDistr_Ineutral) %>% 
  pull(`exhNoDistr_larger`) %>% mean()
```

Estimated main effect of nonExhaustive realization

```{r}
samples.nonExh = posterior_draws %>% 
  mutate(
    nonExhE_Eneutral = b_Intercept,
    nonExhE_Eifp = b_Intercept + b_questionifp,
    nonExhE_Ewillq = b_Intercept + b_questionwillq,
    nonExhE_Ineutral = b_Intercept + b_exhNoDistr,
    nonExhE_Iifp = b_Intercept + b_exhNoDistr + b_questionifp + `b_exhNoDistr:questionifp`,
    nonExhE_Iwillq = b_Intercept + b_exhNoDistr + b_questionwillq + `b_exhNoDistr:questionwillq`,
    
    nonExhI_Eneutral = b_Intercept + b_nonExhInternal,
    nonExhI_Eifp = b_Intercept + b_nonExhInternal + b_questionifp + `b_nonExhInternal:questionifp`,
    nonExhI_Ewillq = b_Intercept + b_nonExhInternal + b_questionwillq + `b_nonExhInternal:questionwillq`,
    nonExhI_Ineutral = b_Intercept + b_exhNoDistr + b_nonExhInternal + `b_exhNoDistr:nonExhInternal`,
    nonExhI_Iifp = b_Intercept + b_exhNoDistr + b_nonExhInternal + b_questionifp + 
      `b_nonExhInternal:questionifp` + `b_exhNoDistr:nonExhInternal` + `b_exhNoDistr:questionifp` + 
      `b_exhNoDistr:nonExhInternal:questionifp`,
    nonExhI_Iwillq = b_Intercept + b_exhNoDistr + b_nonExhInternal + b_questionwillq + 
      `b_nonExhInternal:questionwillq` + `b_exhNoDistr:nonExhInternal` + `b_exhNoDistr:questionwillq` + 
      `b_exhNoDistr:nonExhInternal:questionwillq`)

coeffs.nonExh = samples.nonExh %>% 
  transmute(nonExhE = (nonExhE_Eneutral + nonExhE_Eifp + nonExhE_Ewillq + nonExhE_Ineutral + nonExhE_Iifp + nonExhE_Iwillq)/6,
            nonExhI = (nonExhI_Eneutral + nonExhI_Eifp + nonExhI_Ewillq + nonExhI_Ineutral + nonExhI_Iifp + nonExhI_Iwillq)/6)
means = coeffs.nonExh %>% 
  summarize(mean_nonExhE = mean(nonExhE), mean_nonExhI = mean(nonExhI))
coeffs.nonExh %>% pivot_longer(cols=everything()) %>% 
  ggplot(aes(x=value, color=name)) + geom_density()

p.nonExh = coeffs.nonExh %>% rowid_to_column() %>% 
  pivot_longer(cols=c(nonExhE, nonExhI)) %>%
  ggplot(aes(x=name, y=value)) + 
  geom_boxplot() +
  labs(x = "estimated coefficient", y = "posterior samples") +
  scale_x_discrete(labels = c(
    nonExhE = parse(text=TeX("$\\hat{\\beta}_{nonExhE}$")),
    nonExhI = parse(text=TeX("$\\hat{\\beta}_{nonExhI}$"))
    )
  )
p.nonExh
ggsave(file.path(plot_dir, "main-effect-nonExhaustive.pdf"), p.exh,
       width=7, height=4)
```

1. exhaustive:noDistr is very likely to yield a higher selection rate of the 
exhaustive picture when QUD is neutral.

2. exhaustive kept as Distr (1) and as NoDistr (2): is there a difference
between non-exhaustive = external or non-exhaustive = internal?

```{r}
# exhaustive: no Distractor
samples.nonExh %>% dplyr::select(nonExhE_Ineutral, nonExhI_Ineutral) %>% 
  transmute(nonExhE_larger = nonExhE_Ineutral > nonExhI_Ineutral) %>% 
  pull(nonExhE_larger) %>% mean()

# exhaustive: Distractor
samples.nonExh %>% dplyr::select(nonExhE_Eneutral, nonExhI_Eneutral) %>% 
  transmute(nonExhE_larger = nonExhE_Eneutral > nonExhI_Eneutral) %>% 
  pull(nonExhE_larger) %>% mean()
```

Estimated main effect of picture pairs

```{r}
samples.picPair = posterior_draws %>% 
  mutate(
    D = b_Intercept + (b_Intercept + b_questionifp) + (b_Intercept + b_questionwillq),
    C = b_Intercept + b_nonExhInternal + 
      (b_Intercept + b_nonExhInternal + b_questionifp + `b_nonExhInternal:questionifp`) +
      (b_Intercept + b_nonExhInternal + b_questionwillq + `b_nonExhInternal:questionwillq`),
    B = (b_Intercept + b_exhNoDistr) + 
      (b_Intercept + b_exhNoDistr + b_questionifp + `b_exhNoDistr:questionifp`) +
      (b_Intercept + b_exhNoDistr + b_questionwillq + `b_exhNoDistr:questionwillq`),
    A = (b_Intercept + b_exhNoDistr + b_nonExhInternal + `b_exhNoDistr:nonExhInternal`) +
      (b_Intercept + b_exhNoDistr + b_nonExhInternal + b_questionifp + 
      `b_nonExhInternal:questionifp` + `b_exhNoDistr:nonExhInternal` + `b_exhNoDistr:questionifp` + 
      `b_exhNoDistr:nonExhInternal:questionifp`) + 
      (b_Intercept + b_exhNoDistr + b_nonExhInternal + b_questionwillq + 
      `b_nonExhInternal:questionwillq` + `b_exhNoDistr:nonExhInternal` + `b_exhNoDistr:questionwillq` + 
      `b_exhNoDistr:nonExhInternal:questionwillq`)
  )

coeffs.picPair = samples.picPair %>% 
  transmute(D = D/3, C = C/3, B = B/3, A = A/3)
means = coeffs.picPair %>% 
  summarize(mean_D = mean(D), mean_C = mean(C), mean_B = mean(B), mean_A = mean(A))
coeffs.picPair %>% pivot_longer(cols=everything()) %>% 
  ggplot(aes(x=value, color=name)) + geom_density()

p.picPair = coeffs.picPair %>% rowid_to_column() %>% 
  pivot_longer(cols=c(D, C, B, A)) %>%
  ggplot(aes(x=name, y=value)) + 
  geom_boxplot() +
  labs(x = "estimated coefficient", y = "posterior samples") +
  scale_x_discrete(labels = c(
    A = parse(text=TeX("$\\hat{\\beta}_{A}$")),
    B = parse(text=TeX("$\\hat{\\beta}_{B}$")),
    C = parse(text=TeX("$\\hat{\\beta}_{C}$")),
    D = parse(text=TeX("$\\hat{\\beta}_{D}$"))
    )
  )
p.picPair
ggsave(file.path(plot_dir, "main-effect-picPair.pdf"), p.picPair, width=7, height=4)
```

# Reaction times

Look at reaction times split across all picture pairs

```{r}
critical.RT = data.critical %>% 
  dplyr::select(submission_id, QUD, RT, picPair.long, selected_pic, picPair.short) %>%
  mutate(visual_diff = case_when(picPair.short %in% c("B", "C") ~ T, 
                                 T ~ F)) %>% 
  group_by(QUD, picPair.long) 
critical.RT_means = critical.RT %>% 
  summarize(mean_RT = mean(RT), .groups = "drop_last")

bootstrap_RTs = group_map(critical.RT, function(df, df.group){
  bootstrap = map(seq(1, N), function(i){
    tibble(mean_RT = mean(sample(df$RT, n_participants, replace=T)))
  }) %>% bind_rows() %>% 
    add_column(picPair.long = df.group$picPair.long, QUD = df.group$QUD) %>% 
    arrange(mean_RT)
  
  CI.bounds = bootstrap_bounds(bootstrap)
  ci.low = bootstrap[CI.bounds[["low"]], ]$mean_RT
  ci.up = bootstrap[CI.bounds[["up"]], ]$mean_RT
  bootstrap %>% add_column(ci.low=ci.low, ci.up=ci.up)
}) %>% bind_rows() %>% group_by(picPair.long, QUD)

bootstrap_RTs.CI.question_pic = bootstrap_RTs %>%
  dplyr::select(-mean_RT) %>% distinct()

left_join(critical.RT_means, bootstrap_RTs.CI.question_pic) %>% 
  ggplot(aes(x=mean_RT, y=picPair.long, fill=QUD)) + 
  geom_bar(stat="identity", position = position_dodge()) + 
  geom_errorbar(aes(xmin=ci.low, xmax=ci.up), position = position_dodge())# +
```

```{r}
p.rt = critical.RT %>%
  ggplot(aes(x=log(RT), color=picPair.long)) + geom_density() +
  guides(color = guide_legend(ncol=2))  +
  scale_color_brewer(name = "stimulus", palette = "Set2")

p.rt
p.rt + facet_wrap(~QUD)
ggsave(file.path(plot_dir, "empiric-rts.pdf"), p.rt, width=7, height=4)
```

```{r}
df.rt = critical.RT %>% 
  dplyr::select(submission_id, QUD, RT, picPair.long, picPair.short) %>% 
  #filter(!submission_id %in% ids.scores) %>% 
  separate(col = picPair.long, into = c("exh_situation", "nonExh_situation"), sep="-") %>% 
  mutate(exh_situation = str_sub(exh_situation, start=4),
         exh_situation = factor(exh_situation, 
                                levels = c("withDistractor", "w/oDistractor")))

df.rt_means = df.rt %>% 
  group_by(QUD, exh_situation, nonExh_situation, picPair.short) %>% 
  summarize(mean_rt = mean(RT), .groups = "drop_last")

p <- df.rt_means %>% ggplot(aes(x=exh_situation, y=mean_rt, color=nonExh_situation)) +
  geom_point(aes(shape = QUD)) +
  geom_line(aes(group=interaction(QUD, nonExh_situation))) +
  labs(y = "average reaction time", x = "exhaustive situation") +
  scale_color_brewer(name = "non-exhaustive situation", palette = "Set2")
  # annotate("text", x=rep("withDistractor", 2), y=c(14000, 16000), 
  #               label=c("C", "D"), hjust=2) +
  # annotate("text", x=rep("w/oDistractor", 2), y=c(13500, 15500), 
  #               label=c("A", "B"), hjust=-2)
p 
ggsave(file.path(plot_dir, "reaction-times-233.pdf"), p, width=7, height=4)

```


# TODO: model rts
When the non-exhaustive picture is external (B + D) participants seem to respond 
more slowly than when the non-exhaustive picture is internal (A + C), when 
question=ifp or question=willq.


```{r}
# model_path = here("results", "brms-model-rts233.rds")
# if(file.exists(model_path)) {
#   fit_rt <- readRDS(model_path)
# } else {
#   fit_rt <- brm(
#     data = df.rt %>% 
#       rename(exh=exh_situation, nonExh=nonExh_situation, picPair=picPair.short),
#     family = lognormal(),
#     # RT ~ 1 + exh * nonExh * question + (1 + exh + nonExh + question|submission_id),
#     RT ~ 1 + picPair * question + (1 + picPair + question | submission_id),
#     seed = 1, control = list(adapt_delta = 0.99), iter = 4000
#   )
#   saveRDS(fit_rt, file=model_path)
# }
# fixef(fit_rt)
# pp_check(fit_rt)
# mcmc_plot(fit_rt)
# 
# pp_check(fit_rt, type = "stat", stat = 'mean', nsamples = 100)

```


## Training data

Sanity check: does ratio of correct answers increase with increasing trial numbers?

```{r}
data.train = data %>% filter(type=="training") %>%
  mutate(correct=case_when(expected == response ~ T, T ~ F))

# ratio correct per trial number (different order per participant)
train.correct.nb = data.train %>% group_by(trial_number) %>% 
  summarize(ratio_correct = mean(correct))
train.correct.nb %>% 
  ggplot(aes(x=trial_number, y=ratio_correct)) + 
  geom_bar(stat="identity") + 
  scale_x_continuous(breaks=seq(1, 7))

# ratio correct per trial id
train.correct.id = data.train %>% group_by(id) %>% 
  summarize(ratio_correct = mean(correct))
train.correct.id %>% 
  ggplot(aes(x=id, y=ratio_correct)) + 
  geom_bar(stat="identity") +
  theme(axis.text.x=element_text(angle=90))
```

